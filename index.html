<!DOCTYPE html>
<html>
<head>
    <title>3D Heart Morph</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; }
        button { padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 8px; border: none; background: #ff0044; color: #fff; font-weight: bold; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <button id="startBtn">START HEART SYSTEM</button>
        <p style="color: white; margin-top: 10px;">Please allow camera access when prompted</p>
    </div>
    <video id="video"></video>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const startBtn = document.getElementById('startBtn');
        const ui = document.getElementById('ui');

        startBtn.addEventListener('click', () => {
            ui.style.display = 'none';
            init();
        });

       function init() {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const particleCount = 2000;
    const geometry = new THREE.BufferGeometry();
    
    // Arrays for current positions and "target" (Heart) positions
    const posArray = new Float32Array(particleCount * 3);
    const targetArray = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        // Start as random cloud
        posArray[i * 3] = (Math.random() - 0.5) * 10;
        posArray[i * 3 + 1] = (Math.random() - 0.5) * 10;
        posArray[i * 3 + 2] = (Math.random() - 0.5) * 10;

        // Calculate Heart Target
        const t = Math.random() * Math.PI * 2;
        // x
        targetArray[i * 3] = 0.15 * (16 * Math.pow(Math.sin(t), 3));
        // y
        targetArray[i * 3 + 1] = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        // z (add slight depth)
        targetArray[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const material = new THREE.PointsMaterial({ size: 0.07, color: 0xff0044, transparent: true });
    const points = new THREE.Points(geometry, material);
    scene.add(points);
    camera.position.z = 5;

    let isHandPresent = false;

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.5 });
    hands.onResults((res) => {
        isHandPresent = res.multiHandLandmarks.length > 0;
    });

    const videoElement = document.getElementById('video');
    const cam = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); } });
    cam.start();

    function animate() {
        requestAnimationFrame(animate);
        const positions = geometry.attributes.position.array;

        for (let i = 0; i < particleCount * 3; i++) {
            // If hand is seen, lerp (move) toward Heart target
            if (isHandPresent) {
                positions[i] += (targetArray[i] - positions[i]) * 0.05;
            } else {
                // If no hand, drift back to random
                positions[i] += (Math.random() - 0.5) * 0.01;
            }
        }
        geometry.attributes.position.needsUpdate = true;
        points.rotation.y += 0.01;
        renderer.render(scene, camera);
    }
    animate();
}
    </script>
</body>
</html>

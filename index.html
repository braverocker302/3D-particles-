<!DOCTYPE html>
<html>
<head>
    <title>3D Heart Morph</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; }
        button { padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 8px; border: none; background: #ff0044; color: #fff; font-weight: bold; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <button id="startBtn">START HEART SYSTEM</button>
    </div>
    <video id="video"></video>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const startBtn = document.getElementById('startBtn');
        const ui = document.getElementById('ui');

        startBtn.addEventListener('click', () => {
            ui.style.display = 'none';
            init();
        });

        function init() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const particleCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            const targetArray = new Float32Array(particleCount * 3);
            const initialArray = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                // Random Cloud (Initial)
                initialArray[i * 3] = (Math.random() - 0.5) * 12;
                initialArray[i * 3 + 1] = (Math.random() - 0.5) * 12;
                initialArray[i * 3 + 2] = (Math.random() - 0.5) * 12;
                
                // Heart Math (Target)
                const t = Math.random() * Math.PI * 2;
                targetArray[i * 3] = 0.15 * (16 * Math.pow(Math.sin(t), 3));
                targetArray[i * 3 + 1] = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                targetArray[i * 3 + 2] = (Math.random() - 0.5) * 1.5;

                posArray[i * 3] = initialArray[i * 3];
                posArray[i * 3 + 1] = initialArray[i * 3 + 1];
                posArray[i * 3 + 2] = initialArray[i * 3 + 2];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const material = new THREE.PointsMaterial({ size: 0.06, color: 0xff3366, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(geometry, material);
            scene.add(points);
            camera.position.z = 6;

            let isHandPresent = false;
            const videoElement = document.getElementById('video');
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.6 });
            hands.onResults((res) => { isHandPresent = res.multiHandLandmarks.length > 0; });

            const cam = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cam.start();

            function animate() {
                requestAnimationFrame(animate);
                const positions = geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount * 3; i++) {
                    const target = isHandPresent ? targetArray[i] : initialArray[i];
                    // Smooth movement (lerp)
                    positions[i] += (target - positions[i]) * 0.05;
                }

                geometry.attributes.position.needsUpdate = true;
                points.rotation.y += 0.005;
                renderer.render(scene, camera);
            }
            animate();
        }
    </script>
</body>
</html>
